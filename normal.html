<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Stacking Rectangles with Sound & Recording</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .control-panel {
            position: absolute;
            top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            z-index: 10;
        }
        .control-panel button,
        .control-panel input {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
        .control-panel input[type="range"] {
            width: 200px;
        }
        .control-panel .speed-text {
            font-size: 16px;
            margin-left: 10px;
        }
    </style>
</head>
<body>

<div class="control-panel">
    <button id="recordButton">Start Recording</button>
    <button id="uploadButton">Upload Image</button>
    <input id="speedSlider" type="range" min="50" max="1000" value="300" step="50">
    <span class="speed-text" id="speedValue">Speed: 300</span>
</div>

<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const recordButton = document.getElementById("recordButton");
    const uploadButton = document.getElementById("uploadButton");
    const speedSlider = document.getElementById("speedSlider");
    const speedValue = document.getElementById("speedValue");

    let recorder;
    let chunks = [];
    let videoStream;
    let audioContext;
    let audioStream;

    let randomPattern = true;
    let drawingInterval = 300; // Initial drawing speed interval

    let colorPalette = [];

    // Scale the canvas to the full window size
    function resizeCanvas() {
        const aspectRatio = 16 / 9; // Standard video ratio (adjustable if you want a different ratio)
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        if (windowWidth / windowHeight > aspectRatio) {
            canvas.width = windowHeight * aspectRatio;
            canvas.height = windowHeight;
        } else {
            canvas.width = windowWidth;
            canvas.height = windowWidth / aspectRatio;
        }
    }

    function getRandomColor() {
        // Use a random color from the image palette if available
        if (colorPalette.length > 0) {
            return colorPalette[Math.floor(Math.random() * colorPalette.length)];
        }
        return `hsl(${Math.random() * 360}, 80%, 60%)`;
    }

    function playSound() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.type = ["sine", "square", "triangle", "sawtooth"][Math.floor(Math.random() * 4)];
        
        // Use the speed value for frequency: higher speed -> higher frequency
        osc.frequency.value = (Math.random() * (speedSlider.value)) + 200; // Incorporating speed into frequency

        gain.gain.value = Math.random() * 0.5;

        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.start();
        setTimeout(() => {
            osc.stop();
        }, 150);
    }

    function drawRectangle() {
        const width = Math.random() * 150 + 20;
        const height = Math.random() * 150 + 20;
        const angle = Math.random() * 360;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const spread = Math.random() < 0.7 ? 200 : canvas.width;

        const x = centerX + (Math.random() - 0.5) * spread;
        const y = centerY + (Math.random() - 0.5) * spread;

        ctx.fillStyle = getRandomColor();
        ctx.save();
        ctx.translate(x + width / 2, y + height / 2);
        ctx.rotate(angle * Math.PI / 180);
        ctx.fillRect(-width / 2, -height / 2, width, height);
        ctx.restore();

        if (Math.random() < 0.5) {
            playSound();
        }

        if (Math.random() < 0.1) {
            playSound();
        }
    }

    function drawCircle() {
        const radius = Math.random() * 100 + 50;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const spread = Math.random() < 0.7 ? 200 : canvas.width;

        const x = centerX + (Math.random() - 0.5) * spread;
        const y = centerY + (Math.random() - 0.5) * spread;

        ctx.fillStyle = getRandomColor();
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        playSound();
    }

    function drawPolygon() {
        const sides = Math.floor(Math.random() * 5) + 3; // between 3 and 7 sides
        const radius = Math.random() * 100 + 50;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const spread = Math.random() < 0.7 ? 200 : canvas.width;

        const x = centerX + (Math.random() - 0.5) * spread;
        const y = centerY + (Math.random() - 0.5) * spread;

        ctx.fillStyle = getRandomColor();
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = (i * 2 * Math.PI) / sides;
            const px = x + radius * Math.cos(angle);
            const py = y + radius * Math.sin(angle);
            ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        playSound();
    }

    function startDrawing() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        setInterval(() => {
            [drawRectangle, drawCircle, drawPolygon][Math.floor(Math.random() * 3)]();
        }, drawingInterval);
    }

    function startRecording() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height); 

        if (recorder) {
            recorder.stop();
        }

        videoStream = canvas.captureStream(30);

        // Combine the audio and video streams
        const combinedStream = new MediaStream();
        videoStream.getTracks().forEach(track => combinedStream.addTrack(track));
        audioStream.getTracks().forEach(track => combinedStream.addTrack(track));

        recorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm' });

        chunks = [];
        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.onstop = saveRecording;

        recorder.start();
        recordButton.textContent = "Recording...";
        recordButton.disabled = true;
        uploadButton.disabled = true; // Hide upload image button during recording

        setTimeout(() => {
            recorder.stop();
            recordButton.textContent = "Start Recording";
            recordButton.disabled = false;
            uploadButton.disabled = false; // Show upload image button again after recording
        }, 5000);
    }

    function saveRecording() {
        const blob = new Blob(chunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "recording.mp4";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // Event listeners
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    startDrawing();

    recordButton.addEventListener("click", startRecording);
    uploadButton.addEventListener("click", () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Don't draw the image, just extract colors
                        extractColorsFromImage(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        };
        input.click();
    });

    function extractColorsFromImage(img) {
        // Create an offscreen canvas to extract image data
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tempCtx.drawImage(img, 0, 0);

        // Get pixel data
        const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
        const data = imageData.data;
        
        colorPalette = [];
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            colorPalette.push(`rgb(${r},${g},${b})`);
        }
    }

    speedSlider.addEventListener("input", (e) => {
        drawingInterval = parseInt(e.target.value);
        speedValue.textContent = `Speed: ${drawingInterval}`;
    });

</script>

</body>
</html>
